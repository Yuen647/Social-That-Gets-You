<template>
    <div class="page-container">
        <el-card class="content-card" shadow="never" v-if="note">
            <!-- ÊñáÁ´†Â§¥ÈÉ® -->
            <div class="article-header">
                <h1 class="article-title">{{ note.title }}</h1>
                <div class="article-meta">
                    <div class="author-info" @click="goToUserDetail(note.creatorId)">
                        <img :src="note.avatar" alt="Creator Avatar" class="author-avatar" />
                        <div class="author-details">
                            <span class="author-name">{{ note.creatorName }}</span>
                            <span class="publish-time">{{ note.updateTime }}</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ÂõæÁâáËΩÆÊí≠ -->
            <div class="image-gallery" v-if="note.imgUris && note.imgUris.length">
                <el-carousel :interval="4000" type="card" height="400px">
                    <el-carousel-item v-for="(img, index) in note.imgUris" :key="index">
                        <div class="carousel-image-wrapper">
                            <img :src="img" :alt="`Image ${index + 1}`" class="carousel-image" />
                        </div>
                    </el-carousel-item>
                </el-carousel>
            </div>

            <!-- ÊñáÁ´†ÂÜÖÂÆπ -->
            <div class="article-content">
                <p>{{ note.content }}</p>
            </div>

            <!-- ËØÑËÆ∫Âå∫ -->
            <div class="comments-section" id="comments">
                <div class="comments-header">
                    <h3 class="section-title">ËØÑËÆ∫ ({{ commentCount }})</h3>
                </div>

                <!-- ËØÑËÆ∫ËæìÂÖ•Ê°Ü -->
                <div class="comment-form">
                    <el-input 
                        v-model="newComment.content"
                        type="textarea"
                        :rows="3"
                        placeholder="ÂÜô‰∏ã‰Ω†ÁöÑËØÑËÆ∫..."
                        :maxlength="500"
                        show-word-limit
                    />
                    <div class="comment-tools">
                        <!-- Ë°®ÊÉÖÈÄâÊã©Âô®Êîπ‰∏∫‰∏ãÊãâËèúÂçï -->
                        <el-dropdown @command="insertEmoji" trigger="click">
                            <el-button type="text" class="tool-btn">
                                üòä Ë°®ÊÉÖ
                            </el-button>
                            <template #dropdown>
                                <el-dropdown-menu class="emoji-grid-menu">
                                    <div class="emoji-grid-container">
                                        <el-dropdown-item 
                                            v-for="emoji in commonEmojis" 
                                            :key="emoji"
                                            :command="emoji"
                                            class="emoji-grid-item">
                                            {{ emoji }}
                                        </el-dropdown-item>
                                    </div>
                                </el-dropdown-menu>
                            </template>
                        </el-dropdown>

                        <!-- Âø´Êç∑ÂõûÂ§ç‰øùÊåÅ‰∏çÂèò -->
                        <el-dropdown @command="insertQuickReply">
                            <el-button type="text" class="tool-btn">
                                <el-icon><ChatLineSquare /></el-icon>
                                Âø´Êç∑ÂõûÂ§ç
                            </el-button>
                            <template #dropdown>
                                <el-dropdown-menu>
                                    <el-dropdown-item 
                                        v-for="(reply, index) in quickReplies"
                                        :key="index"
                                        :command="reply">
                                        {{ reply }}
                                    </el-dropdown-item>
                                </el-dropdown-menu>
                            </template>
                        </el-dropdown>
                    </div>
                    <div class="form-actions">
                        <el-button type="primary" @click="submitComment" :loading="loading.submit">
                            ÂèëÂ∏ÉËØÑËÆ∫
                        </el-button>
                    </div>
                </div>

                <!-- ËØÑËÆ∫ÂàóË°® -->
                <div class="comments-list" v-loading="loading.comments">
                    <template v-if="comments.length">
                        <div v-for="comment in comments" 
                             :key="comment.commentId" 
                             class="comment-item">
                            <div class="comment-main">
                                <div class="comment-user">
                                    <img :src="comment.userAvatar" 
                                         :alt="comment.userName" 
                                         class="user-avatar"
                                         @click="goToUserDetail(comment.userId)" />
                                    <div class="user-info">
                                        <span class="user-name">{{ comment.userName }}</span>
                                        <span class="comment-time">{{ comment.createTime }}</span>
                                    </div>
                                </div>
                                <div class="comment-content">{{ comment.content }}</div>
                                <div class="comment-actions">
                                    <el-button type="text" @click="toggleCommentReply(comment)">
                                        ÂõûÂ§ç
                                    </el-button>
                                    <el-button 
                                        v-if="comment.replies?.length"
                                        type="text"
                                        @click="toggleReplies(comment.commentId)">
                                        {{ isRepliesCollapsed[comment.commentId] ? 'Â±ïÂºÄÂõûÂ§ç' : 'Êî∂Ëµ∑ÂõûÂ§ç' }}
                                        ({{ comment.replies.length }})
                                    </el-button>
                                </div>

                                <!-- ÂõûÂ§çÂàóË°® -->
                                <div v-if="!isRepliesCollapsed[comment.commentId] && comment.replies?.length"
                                     class="replies-list">
                                    <div v-for="reply in comment.replies"
                                         :key="reply.id"
                                         class="reply-item">
                                        <div class="reply-content">
                                            <span class="reply-user" @click="goToUserDetail(reply.userId)">{{ reply.userName }}</span>
                                            <template v-if="reply.replyToUserId">
                                                <span class="reply-arrow">ÂõûÂ§ç</span>
                                                <span class="reply-to-user" @click="goToUserDetail(reply.replyToUserId)">@{{ reply.replyToUserName }}</span>
                                            </template>
                                            <span class="reply-text">Ôºö{{ reply.content }}</span>
                                        </div>
                                        <div class="reply-footer">
                                            <span class="reply-time">{{ reply.createTime }}</span>
                                            <div class="reply-actions">
                                                <el-button type="text" size="small" @click="toggleNestedReply(comment.commentId, reply)">
                                                    ÂõûÂ§ç
                                                </el-button>
                                                <el-button 
                                                    v-if="isCurrentUser(reply.userId)"
                                                    type="text" 
                                                    size="small" 
                                                    @click="deleteReply(comment.commentId, reply.id)">
                                                    Âà†Èô§
                                                </el-button>
                                            </div>
                                        </div>
                                        <!-- ÂµåÂ•óÂõûÂ§çÁöÑËæìÂÖ•Ê°Ü -->
                                        <div v-if="replyInputs[`${comment.commentId}-${reply.id}`]" class="nested-reply-form">
                                            <el-input 
                                                v-model="replyContent[`${comment.commentId}-${reply.id}`]"
                                                type="textarea"
                                                :rows="2"
                                                :placeholder="`ÂõûÂ§ç @${reply.userName}`"
                                            ></el-input>
                                            <div class="reply-actions">
                                                <el-button size="small" @click="submitNestedReply(comment.commentId, reply)">
                                                    ÂèëÈÄÅ
                                                </el-button>
                                                <el-button size="small" type="text" @click="cancelNestedReply(comment.commentId, reply)">
                                                    ÂèñÊ∂à
                                                </el-button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- ÂõûÂ§çËæìÂÖ•Ê°Ü -->
                                <div v-if="replyInputs[comment.commentId]" class="reply-form">
                                    <el-input 
                                        v-model="replyContent[comment.commentId]"
                                        type="textarea"
                                        :rows="2"
                                        :placeholder="`ÂõûÂ§ç @${comment.userName}`"
                                    ></el-input>
                                    <div class="reply-actions">
                                        <el-button size="small" @click="submitCommentReply(comment)">
                                            ÂèëÈÄÅ
                                        </el-button>
                                        <el-button size="small" type="text" @click="cancelCommentReply(comment.commentId)">
                                            ÂèñÊ∂à
                                        </el-button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                    <div v-else class="no-comments">
                        ÊöÇÊó†ËØÑËÆ∫ÔºåÊù•Êä¢Ê≤ôÂèëÂêß~
                    </div>
                </div>

                <!-- ÂàÜÈ°µÂô® -->
                <el-pagination
                    v-if="comments.length"
                    class="pagination"
                    background
                    layout="prev, pager, next"
                    :total="pagination.total"
                    :page-size="pagination.size"
                    :current-page="pagination.page"
                    @current-change="handlePageChange"
                />
            </div>
        </el-card>
        <div v-else class="loading-placeholder">
            <el-skeleton :rows="10" animated />
        </div>

        <!-- ÊÇ¨ÊµÆÁÇπËµûÊåâÈíÆ -->
        <div class="floating-actions">
            <div class="action-button like-button" 
                 :class="{ 'is-liked': isLiked }"
                 @click="toggleLike">
                <div class="button-content">
                    <el-icon size="24"><Star /></el-icon>
                    <span class="like-count">{{ likeCount }}</span>
                </div>
                <div class="tooltip">{{ isLiked ? 'ÂèñÊ∂àÁÇπËµû' : 'ÁÇπËµû' }}</div>
            </div>
            <div class="action-button comment-button" @click="scrollToComments">
                <div class="button-content">
                    <el-icon size="24"><ChatDotRound /></el-icon>
                    <span class="comment-count">{{ commentCount }}</span>
                </div>
                <div class="tooltip">ËØÑËÆ∫</div>
            </div>
        </div>
    </div>
</template>

<script>
import { getNoteDetailService, addCommentService, getNoteCommentsService, getCommentRepliesService, getCommentCountService, deleteCommentService } from "@/api/note.js";
import { getUserInfoByIdService, getUserInfo } from "@/api/user.js";
import { ElMessage } from "element-plus";
import { dolikeNoteService, nolikeNoteService, doCollectService, unCollectService, noteCountService } from "@/api/collect.js";
import { 
    StarFilled, 
    ChatLineSquare,
    ChatDotRound,
    Star,
    Edit  // ÂèØ‰ª•Áî®‰ΩúË°®ÊÉÖÂõæÊ†á
} from '@element-plus/icons-vue';

export default {
    data() {
        return {
            note: null, // ÂΩìÂâçÁ¨îËÆ∞ÊÉÖ
            comments: [], // ËØÑËÆ∫ÂàóË°®
            newComment: { content: "" }, // Êñ∞ËØÑËÆ∫ÂÜÖÂÆπ
            replyInputs: {}, // ÊéßÂà∂ÊØè‰∏™ËØÑËÆ∫ÁöÑÂõûÂ§çËæìÂÖ•Ê°ÜÊòØÂê¶ÊòæÁ§∫
            replyContent: {}, // Â≠òÂÇ®ÊØè‰∏™ËØÑËÆ∫ÁöÑÂõûÂ§çÂÜÖÂÆπ
            isLiked: false,
            likeCount: 0,
            pagination: {
                page: 1,
                size: 10,
                total: 0
            },
            loading: {
                comments: false,
                replies: false,
                submit: false
            },
            activeReply: null, // ÂΩìÂâçÊ≠£Âú®ÂõûÂ§çÁöÑËØÑËÆ∫
            commonEmojis: ['üòä', 'üòÇ', 'üëç', '‚ù§Ô∏è', 'üéâ', 'ü§î', 'üëè', 'üôè', 'üí™', '‚ú®', 
                          'üåü', 'üî•', 'üíØ', 'üé®', 'üí°', 'üí™', 'üåà', 'üéµ', 'üé∏', '‚ö°Ô∏è'],
            quickReplies: [
                'ÂÜôÂæóÁúüÂ•ΩÔºÅÊîØÊåÅ‰∏Ä‰∏ã~',
                'ÊÑüË∞¢ÂàÜ‰∫´ÔºåÂ≠¶‰π†‰∫ÜÔºÅ',
                'Ëøô‰∏™ËßÇÁÇπÂæàÊúâÊÑèÊÄù',
                'ÊúüÂæÖÊõ¥Â§öÁ≤æÂΩ©ÂÜÖÂÆπ',
                'ËµûÂêå‰Ω†ÁöÑÁúãÊ≥ï',
                'ÊúâÊ∑±Â∫¶ÔºåÂÄºÂæóÊÄùËÄÉ',
                'ÈùûÂ∏∏‰∏ì‰∏öÁöÑËßÅËß£',
                'ËØ¥ÂæóÂØπÔºåÊî∂Ëóè‰∫Ü',
                'ÂàÜÊûêÂæóÂæàÂà∞‰Ωç',
                'ÁªßÁª≠Âä†Ê≤πÔºÅ'
            ],
            commentCount: 0, // Ê∑ªÂä†ËØÑËÆ∫ÊÄªÊï∞
            currentUserId: null, // ÂΩìÂâçÁôªÂΩïÁî®Êà∑ID
            isRepliesCollapsed: {}, // ÊéßÂà∂ËØÑËÆ∫ÁöÑÂõûÂ§çÊòØÂê¶ÊäòÂè†
            showEmojiPicker: false, // ÊéßÂà∂Ë°®ÊÉÖÈÄâÊã©Âô®ÁöÑÊòæÁ§∫
        };
    },
    methods: {
        async fetchNoteCount() {
            const noteId = this.$route.params.id;
            if (!noteId) {
                console.warn("Note ID is invalid. Skipping fetchNoteCount.");
                return;
            }
            try {
                const response = await noteCountService({ noteId });
                console.log("Â∏ñÂ≠êËÆ°Êï∞Êé•Âè£ËøîÂõûÊï∞ÊçÆÔºö", response);
                if (response.success) {
                    this.likeCount = response.data.likeTotal || 0;
                    console.log("ÁÇπËµûÊï∞Ôºö", this.likeCount);
                } else {
                    // Êé•Âè£ËøîÂõûÁöÑÊàêÂäüÊ†áËØÜ‰∏∫ falseÂèØ‰ª•Âú®ËøôÈáåËÆæÁΩÆÈªòËÆ§ÂÄº
                    console.warn("Failed to fetch note count, using defaults.");
                    this.likeCount = 0;
                }
            } catch (error) {
                // ÊçïËé∑500ÈîôËØØÔºåÂú®ÊéßÂà∂Âè∞ËÆ∞ÂΩïÔºå‰ΩÜ‰∏çÂºπÈîôËØØÊèêÁ§∫Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄºÂÖúÂ∫ï
                console.error("Ëé∑ÂèñÂ∏ñÂ≠êËÆ°Êï∞‰ø°ÊÅØÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ËÆ°Êï∞ÂÄº:", error);
                this.likeCount = 0;
                // ÂèØÈÄâÔºö‰∏ç‰ΩøÁî® ElMessage ÊèêÁ§∫Áî®Êà∑ÈîôËØØÔºåÂ∞ÜÂÖ∂ÈªòÈªòÂ§ÑÁêÜ
                // ElMessage.error("Ëé∑ÂèñËÆ°Êï∞Â§±Ë¥•ÔºåÂ∑≤‰ΩøÁî®ÈªòËÆ§ÂÄº");
            }
        },
        async fetchNoteDetail() {
            const noteId = this.$route.params.id;
            if (!noteId) {
                console.warn("Note ID is null or undefined. Skipping fetch.");
                return;
            }
            this.note = null;
            try {
                const response = await getNoteDetailService({ id: noteId });
                if (response.success) {
                    this.note = response.data;
                    this.isLiked = JSON.parse(localStorage.getItem(`note_${noteId}_liked`)) || false;
                    await this.fetchNoteCount(); // Ëé∑ÂèñËÆ°Êï∞‰ø°ÊÅØ
                    await this.fetchCommentCount(); // Ê∑ªÂä†ËøôË°å
                    this.fetchComments();
                } else {
                    //ElMessage.error(response.message || "Failed to fetch note details.");
                    console.error("Ëé∑ÂèñÂ∏ñÂ≠êËÆ°Êï∞‰ø°ÊÅØÂ§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ËÆ°Êï∞ÂÄº:", error);
                    this.likeCount = 0;
                }
            } catch (error) {
                console.error("Error fetching note detail:", error);
                ElMessage.error("An error occurred while fetching note details.");
            }
        },
        async fetchComments() {
            const noteId = this.$route.params.id;
            this.loading.comments = true;
            try {
                const response = await getNoteCommentsService({ 
                    noteId, 
                    page: this.pagination.page, 
                    size: this.pagination.size 
                });
                
                if (response.success) {
                    console.log('Comments response:', response.data);
                    
                    if (response.data.records) {
                        this.comments = response.data.records;
                        this.comments.forEach(comment => {
                            console.log('Comment details:', {
                                commentId: comment.commentId,
                                userId: comment.userId,
                                userName: comment.userName,
                                currentUserId: this.currentUserId,
                                canDelete: this.isCurrentUser(comment.userId)
                            });
                        });
                        this.pagination.total = response.data.total;
                    } else {
                        this.comments = Array.isArray(response.data) ? response.data : [];
                        this.pagination.total = this.comments.length;
                    }
                    
                    console.log('Â§ÑÁêÜÂêéËØÑËÆ∫Êï∞ÊçÆ:', this.comments);
                    
                    if (this.comments.length > 0) {
                        await Promise.all(this.comments.map(comment => {
                            console.log('Ëé∑ÂèñËØÑËÆ∫IDÁöÑÂõûÂ§ç:', comment.commentId);
                            return this.fetchReplies(comment.commentId);
                        }));
                    }
                } else {
                    ElMessage.warning(response.message || "Ëé∑ÂèñËØÑËÆ∫Â§±Ë¥•");
                }
            } catch (error) {
                console.error("Ëé∑ÂèñËØÑËÆ∫Âá∫Èîô:", error);
                ElMessage.error("Ëé∑ÂèñËØÑËÆ∫Êó∂ÂèëÁîüÈîôËØØ");
            } finally {
                this.loading.comments = false;
            }
        },
        async fetchReplies(commentId) {
            if (!commentId) {
                console.warn('Invalid commentId:', commentId);
                return;
            }

            this.loading.replies = true;
            try {
                const response = await getCommentRepliesService({ commentId });
                console.log('Replies response for comment', commentId, ':', response);
                
                if (response.success) {
                    const commentIndex = this.comments.findIndex(
                        comment => comment.commentId === commentId
                    );
                    if (commentIndex !== -1) {
                        const replies = await Promise.all((response.data || []).map(async reply => {
                            let replyToUserName = this.comments[commentIndex].userName;
                            let replyToUserId = this.comments[commentIndex].userId;

                            // Â¶ÇÊûúÂõûÂ§çÁöÑÊòØÂÖ∂‰ªñÂõûÂ§çÔºåËé∑ÂèñË¢´ÂõûÂ§çÁî®Êà∑ÁöÑ‰ø°ÊÅØ
                            if (reply.replyToUserId && reply.replyToUserId !== this.comments[commentIndex].userId) {
                                try {
                                    const userResponse = await getUserInfoByIdService({ id: reply.replyToUserId });
                                    if (userResponse.success) {
                                        replyToUserName = userResponse.data.nickName;
                                        replyToUserId = reply.replyToUserId;
                                    }
                                } catch (error) {
                                    console.error('Ëé∑ÂèñË¢´ÂõûÂ§çÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥•:', error);
                                }
                            }
                            
                            return {
                                ...reply,
                                replyToUserName,
                                replyToUserId
                            };
                        }));

                        this.comments[commentIndex] = {
                            ...this.comments[commentIndex],
                            replies: replies
                        };
                        
                        console.log('Â§ÑÁêÜÂêéÁöÑÂõûÂ§çÊï∞ÊçÆ:', replies);
                    }
                }
            } catch (error) {
                console.error("Ëé∑ÂèñÂõûÂ§çÂá∫Èîô:", error);
                ElMessage.error("Ëé∑ÂèñÂõûÂ§çÂ§±Ë¥•");
            } finally {
                this.loading.replies = false;
            }
        },
        async submitComment() {
            if (!this.newComment.content.trim()) {
                ElMessage.warning("ËØÑËÆ∫ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫");
                return;
            }

            this.loading.submit = true;
            try {
                const response = await addCommentService({
                    noteId: this.$route.params.id,
                    content: this.newComment.content,
                    parentId: null // ‰∏ÄÁ∫ßËØÑËÆ∫Êó†Áà∂ËØÑËÆ∫
                });

                if (response.success) {
                    ElMessage.success("ËØÑËÆ∫ÂèëÂ∏ÉÊàêÂäü");
                    this.newComment.content = "";
                    this.pagination.page = 1;
                    await this.fetchCommentCount(); // Ê∑ªÂä†ËøôË°å
                    await this.fetchComments();
                } else {
                    ElMessage.warning(response.message || "ËØÑËÆ∫ÂèëÂ∏ÉÂ§±Ë¥•");
                }
            } catch (error) {
                console.error("ÂèëÂ∏ÉËØÑËÆ∫Âá∫Èîô:", error);
                ElMessage.error("ÂèëÂ∏ÉËØÑËÆ∫Êó∂ÂèëÁîüÈîôËØØ");
            } finally {
                this.loading.submit = false;
            }
        },
        showReplyInput(commentId) {
            this.replyInputs[commentId] = true;
        },
        async submitReply(parentCommentId) {
            const content = this.replyContent[parentCommentId]?.trim();
            if (!content) {
                ElMessage.warning("ÂõûÂ§çÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫");
                return;
            }

            this.loading.submit = true;
            try {
                const response = await addCommentService({
                    noteId: this.$route.params.id,
                    content: content,
                    parentId: parentCommentId
                });

                if (response.success) {
                    ElMessage.success("ÂõûÂ§çÂèëÂ∏ÉÊàêÂäü");
                    this.replyContent[parentCommentId] = "";
                    this.replyInputs[parentCommentId] = false;
                    await this.fetchCommentCount(); // Ê∑ªÂä†ËøôË°å
                    await this.fetchReplies(parentCommentId);
                } else {
                    ElMessage.warning(response.message || "ÂõûÂ§çÂèëÂ∏ÉÂ§±Ë¥•");
                }
            } catch (error) {
                console.error("ÂèëÂ∏ÉÂõûÂ§çÂá∫Èîô:", error);
                ElMessage.error("ÂèëÂ∏ÉÂõûÂ§çÊó∂ÂèëÁîüÈîôËØØ");
            } finally {
                this.loading.submit = false;
            }
        },
        goToUserDetail(userId) {
            this.$router.push({ name: "UserDetail", params: { id: userId } });
        },
        async toggleLike() {
            try {
                if (this.isLiked) {
                    await nolikeNoteService(this.note.id)
                    this.likeCount--
                    ElMessage.success('Â∑≤ÂèñÊ∂àÁÇπËµû')
                } else {
                    await dolikeNoteService(this.note.id)
                    this.likeCount++
                    ElMessage.success('ÁÇπËµûÊàêÂäü')
                }
                this.isLiked = !this.isLiked
            } catch (error) {
                console.error('Toggle like failed:', error)
                ElMessage.error('Êìç‰ΩúÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï')
            }
        },
        scrollToComments() {
            document.getElementById('comments')?.scrollIntoView({ 
                behavior: 'smooth',
                block: 'start'
            })
        },
        async handlePageChange(page) {
            this.pagination.page = page;
            await this.fetchComments();
        },
        // Êç¢‰∏ÄÁ∫ßËØÑËÆ∫ÁöÑÂõûÂ§çËæìÂÖ•Ê°ÜÊòæÁ§∫
        toggleCommentReply(comment) {
            this.replyInputs = {
                ...this.replyInputs,
                [comment.commentId]: !this.replyInputs[comment.commentId]
            };
        },

        // ÂèñÊ∂à‰∏ÄÁ∫ßËØÑËÆ∫ÂõûÂ§ç
        cancelCommentReply(commentId) {
            this.replyInputs[commentId] = false;
            this.replyContent[commentId] = '';
        },

        // Êèê‰∫§‰∏ÄÁ∫ßËØÑËÆ∫ÁöÑÂõûÂ§ç
        async submitCommentReply(comment) {
            if (!comment || !comment.commentId) {
                console.warn("Invalid comment object:", comment);
                return;
            }

            const replyContent = this.replyContent[comment.commentId];
            console.log('Reply content:', replyContent, 'for comment:', comment.commentId);

            if (!replyContent || !replyContent.trim()) {
                ElMessage.warning("ÂõûÂ§çÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫");
                return;
            }

            this.loading.submit = true;
            try {
                const response = await addCommentService({
                    noteId: this.$route.params.id,
                    content: replyContent.trim(),
                    parentId: comment.commentId,
                    replyToUserId: comment.userId
                });

                if (response.success) {
                    ElMessage.success("ÂõûÂ§çÂèëÂ∏ÉÊàêÂäü");
                    this.replyContent[comment.commentId] = "";
                    this.replyInputs[comment.commentId] = false;
                    await this.fetchCommentCount();
                    await this.fetchReplies(comment.commentId);
                } else {
                    ElMessage.warning(response.message || "ÂõûÂ§çÂèëÂ∏ÉÂ§±Ë¥•");
                }
            } catch (error) {
                console.error("ÂèëÂ∏ÉÂõûÂ§çÂá∫Èîô:", error);
                ElMessage.error("ÂèëÂ∏ÉÂõûÂ§çÊó∂ÂèëÁîüÈîôËØØ");
            } finally {
                this.loading.submit = false;
            }
        },

        // ‰∏∫‰∏ÄÁ∫ßËØÑËÆ∫ÊèíÂÖ•Ë°®ÊÉÖ
        insertEmojiToComment(commentId, emoji) {
            const content = this.replyContent[commentId] || '';
            this.replyContent[commentId] = content + emoji;
        },

        // ‰øÆÊîπÂéüÊúâÁöÑ toggleReplyInput ÊñπÊ≥ïÂêçÔºå‰∏ìÈó®Áî®‰∫éÂµåÂ•óÂõûÂ§ç
        toggleNestedReply(commentId, reply) {
            const key = `${commentId}-${reply.id}`;
            this.replyInputs = {
                ...this.replyInputs,
                [key]: !this.replyInputs[key]
            };
            this.activeReply = reply;
            
            if (this.replyInputs[key]) {
                this.$nextTick(() => {
                    const input = this.$refs.replyInput;
                    if (input && input.focus) {
                        input.focus();
                    }
                });
            }
        },

        // ÊèíÂÖ•Ë°®ÊÉÖ
        insertEmoji(emoji) {
            const textarea = document.querySelector('.comment-form .el-textarea__inner')
            if (textarea) {
                const start = textarea.selectionStart
                const end = textarea.selectionEnd
                const text = this.newComment.content
                this.newComment.content = text.substring(0, start) + emoji + text.substring(end)
                // ËÆæÁΩÆÂÖâÊ†á‰ΩçÁΩÆ
                this.$nextTick(() => {
                    textarea.focus()
                    textarea.setSelectionRange(start + emoji.length, start + emoji.length)
                })
            }
        },

        // ÊèíÂÖ•Âø´Êç∑ÂõûÂ§ç
        insertQuickReply(reply) {
            this.newComment.content = reply
        },

        // Âø´Êç∑ÂõûÂ§çÂπ∂Áõ¥Êé•Êèê‰∫§
        async quickReplyAndSubmit(commentId, reply, content) {
            this.loading.submit = true;
            try {
                const response = await addCommentService({
                    noteId: this.$route.params.id,
                    content: content,
                    parentId: commentId,
                    replyToUserId: reply.userId
                });

                if (response.success) {
                    ElMessage.success("ÂõûÂ§çÂèëÂ∏ÉÊàêÂäü");
                    await this.fetchReplies(commentId);
                    await this.fetchCommentCount(); // Ê∑ªÂä†ËøôË°å
                } else {
                    ElMessage.warning(response.message || "ÂõûÂ§çÂèëÂ∏ÉÂ§±Ë¥•");
                }
            } catch (error) {
                console.error("ÂèëÂ∏ÉÂõûÂ§çÂá∫Èîô:", error);
                ElMessage.error("ÂèëÂ∏ÉÂõûÂ§çÂèëÁîüÈîôËØØ");
            } finally {
                this.loading.submit = false;
            }
        },
        async fetchCommentCount() {
            const noteId = this.$route.params.id;
            try {
                const response = await getCommentCountService({ noteId });
                if (response.success) {
                    this.commentCount = response.data || 0;
                } else {
                    console.warn("Failed to fetch comment count");
                    this.commentCount = 0;
                }
            } catch (error) {
                console.error("Error fetching comment count:", error);
                this.commentCount = 0;
            }
        },
        // Êèê‰∫§ÂµåÂ•óÂõûÂ§ç
        async submitNestedReply(commentId, replyTo) {
            const key = `${commentId}-${replyTo.id}`;
            const content = this.replyContent[key]?.trim();
            
            if (!content) {
                ElMessage.warning("ÂõûÂ§çÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫");
                return;
            }

            this.loading.submit = true;
            try {
                const response = await addCommentService({
                    noteId: this.$route.params.id,
                    content: content,
                    parentId: commentId,
                    replyToUserId: replyTo.userId,
                    replyToUserName: replyTo.userName // Ê∑ªÂä†Ë¢´ÂõûÂ§çÁî®Êà∑Âêç
                });

                if (response.success) {
                    ElMessage.success("ÂõûÂ§çÂèëÂ∏ÉÊàêÂäü");
                    // Ê∏ÖÁ©∫ËæìÂÖ•Ê°ÜÂíåÁä∂ÊÄÅ
                    this.replyContent[key] = "";
                    this.replyInputs[key] = false;
                    this.activeReply = null;
                    
                    // ÈáçÊñ∞Ëé∑ÂèñËØÑËÆ∫Êï∞ÊçÆ
                    await this.fetchCommentCount();
                    await this.fetchReplies(commentId);
                } else {
                    ElMessage.warning(response.message || "ÂõûÂ§çÂèëÂ∏ÉÂ§±Ë¥•");
                }
            } catch (error) {
                console.error("ÂèëÂ∏ÉÂõûÂ§çÂá∫Èîô:", error);
                ElMessage.error("ÂèëÂ∏ÉÂõûÂ§çÊó∂ÂèëÁîüÈîôËØØ");
            } finally {
                this.loading.submit = false;
            }
        },

        // ÂèñÊ∂àÂµåÂ•óÂõûÂ§ç
        cancelNestedReply(commentId, reply) {
            if (!reply) return;
            
            const key = `${commentId}-${reply.id}`;
            this.replyInputs[key] = false;
            this.replyContent[key] = '';
            this.activeReply = null;
        },

        // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑‰ø°ÊÅØ
        async getCurrentUser() {
            try {
                const response = await getUserInfo();
                console.log('Current user response:', response);

                if (response.success && response.data) {
                    this.currentUserId = response.data.id;
                    console.log('Set currentUserId to:', this.currentUserId);
                } else {
                    console.warn('Failed to get current user info:', response.message);
                    this.currentUserId = null;
                }
            } catch (error) {
                console.error('Ëé∑ÂèñÂΩìÂâçÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥•:', error);
                this.currentUserId = null;
            }
        },

        // Ê∑ªÂä†ÊùÉÈôêÂà§Êñ≠ÊñπÊ≥ï
        isCurrentUser(userId) {
            // Á°Æ‰øù‰∏§‰∏™ ID ÈÉΩËΩ¨Êç¢‰∏∫Êï∞Â≠óËøõË°åÊØîËæÉ
            const currentId = Number(this.currentUserId);
            const targetId = Number(userId);
            
            const isMatch = currentId && targetId && currentId === targetId;
            console.log('Checking user permission:', {
                currentUserId: currentId,
                targetUserId: targetId,
                currentIdType: typeof currentId,
                targetIdType: typeof targetId,
                isMatch: isMatch
            });
            
            return isMatch;
        },

        // ‰øÆÊîπÂà†Èô§ÊñπÊ≥ïÔºåÊ∑ªÂä†ÊùÉÈôêÂà§Êñ≠
        async deleteComment(commentId) {
            if (!this.currentUserId) {
                ElMessage.warning('ËØ∑ÂÖàÁôªÂΩï');
                return;
            }

            console.log('Â∞ùËØïÂà†Èô§ËØÑËÆ∫:', commentId);
            try {
                console.log('ÂèëÈÄÅÂà†Èô§ËØÑËÆ∫ËØ∑Ê±Ç:', { commentId });
                const response = await deleteCommentService({ commentId });
                console.log('Âà†Èô§ËØÑËÆ∫ÂìçÂ∫î:', response);
                
                if (response.success) {
                    ElMessage.success('ËØÑËÆ∫Âà†Èô§ÊàêÂäü');
                    await this.fetchCommentCount();
                    await this.fetchComments();
                } else {
                    console.warn('Âà†Èô§ËØÑËÆ∫Â§±Ë¥•:', response.message);
                    ElMessage.error(response.message || 'Âà†Èô§Â§±Ë¥•');
                }
            } catch (error) {
                console.error('Âà†Èô§ËØÑËÆ∫Âá∫Èîô:', error);
                ElMessage.error('Âà†Èô§ËØÑËÆ∫Êó∂ÂèëÁîüÈîôËØØ');
            }
        },

        async deleteReply(commentId, replyId) {
            if (!this.currentUserId) {
                ElMessage.warning('ËØ∑ÂÖàÁôªÂΩï');
                return;
            }

            console.log('ËØïÂà†Èô§ÂõûÂ§ç:', { commentId, replyId });
            try {
                console.log('ÂèëÈÄÅÂà†Èô§ÂõûÂ§çËØ∑Ê±Ç:', { commentId: replyId });
                const response = await deleteCommentService({ commentId: replyId });
                console.log('Âà†Èô§ÂõûÂ§çÂìçÂ∫î:', response);
                
                if (response.success) {
                    ElMessage.success('ÂõûÂ§çÂà†Èô§ÊàêÂäü');
                    await this.fetchCommentCount();
                    await this.fetchReplies(commentId);
                } else {
                    console.warn('Âà†Èô§ÂõûÂ§çÂ§±Ë¥•:', response.message);
                    ElMessage.error(response.message || 'Âà†Èô§Â§±Ë¥•');
                }
            } catch (error) {
                console.error('Âà†Èô§ÂõûÂ§çÂá∫Èîô:', error);
                ElMessage.error('Âà†Èô§ÂõûÂ§çÊó∂ÂèëÁîüÈîôËØØ');
            }
        },

        // Ê∑ªÂä†ÊäòÂè†ÂäüËÉΩ
        toggleReplies(commentId) {
            this.isRepliesCollapsed = {
                ...this.isRepliesCollapsed,
                [commentId]: !this.isRepliesCollapsed[commentId]
            };
        }
    },
    async mounted() {
        await this.getCurrentUser();
        this.fetchNoteDetail();
    },
    watch: {
        "$route.params.id": {
            async handler(newId) {
                if (!newId) {
                    console.warn("Route param 'id' is invalid. Skipping fetch.");
                    this.note = null;
                    return;
                }
                this.note = null;
                await this.getCurrentUser(); // ÈáçÊñ∞Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØ
                await this.fetchNoteDetail();
            },
            immediate: true,
        },
    },
    components: {
        StarFilled,
        ChatLineSquare,
        ChatDotRound,
        Star,
        Edit
    }
};
</script>


<style scoped>
.page-container {
    padding: 24px;
    max-width: 1200px;
    margin: 0 auto;
    min-height: 100vh;
    background-color: #f5f7fa;
}

.content-card {
    background: white;
    border-radius: 12px;
}

/* ÊñáÁ´†Â§¥ÈÉ®Ê†∑Âºè */
.article-header {
    margin-bottom: 32px;
}

.article-title {
    font-size: 2.5rem;
    font-weight: 700;
    color: #1a1a1a;
    margin-bottom: 24px;
    line-height: 1.3;
}

.article-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 24px;
    border-bottom: 1px solid #eee;
}

.author-info {
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
}

.author-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    object-fit: cover;
}

.author-details {
    display: flex;
    flex-direction: column;
}

.author-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: #1a1a1a;
}

.publish-time {
    font-size: 0.9rem;
    color: #666;
}

/* ÂõæÁâáËΩÆÊí≠Ê†∑Âºè */
.image-gallery {
    margin: 32px 0;
}

.carousel-image-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f5f5f5;
    border-radius: 8px;
    overflow: hidden;
}

.carousel-image {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

/* ÊñáÁ´†ÂÜÖÂÆπÊ†∑Âºè */
.article-content {
    font-size: 1.1rem;
    line-height: 1.8;
    color: #333;
    margin: 32px 0;
}

/* ËØÑËÆ∫Âå∫Ê†∑Âºè */
.comments-section {
    margin-top: 48px;
    padding-top: 32px;
    border-top: 1px solid #eee;
}

.section-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 24px;
}

.comment-form {
    margin-bottom: 32px;
}

.form-actions {
    display: flex;
    justify-content: flex-end;
    margin-top: 16px;
}

/* ËØÑËÆ∫ÂàóË°®Ê†∑Âºè */
.comment-item {
    padding: 24px 0;
    border-bottom: 1px solid #eee;
}

.comment-user {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
}

.user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
}

.user-info {
    display: flex;
    flex-direction: column;
}

.user-name {
    font-weight: 600;
    color: #1a1a1a;
}

.comment-time {
    font-size: 0.9rem;
    color: #666;
}

.comment-content {
    font-size: 1rem;
    line-height: 1.6;
    color: #333;
    margin: 12px 0;
}

/* ÂõûÂ§çÊ†∑Âºè */
.replies-list {
    margin-left: 52px;
    margin-top: 16px;
    padding: 16px;
    background: #f9f9f9;
    border-radius: 8px;
}

.reply-item {
    padding: 12px 0;
    border-bottom: 1px solid #eee;
}

.reply-item:last-child {
    border-bottom: none;
}

.reply-content {
    display: flex;
    gap: 8px;
    align-items: baseline;
    margin-bottom: 8px;
}

.reply-user {
    font-weight: 600;
    color: #1a1a1a;
    cursor: pointer;
}

.reply-user:hover {
    color: #409EFF;
}

.reply-arrow {
    color: #909399;
    font-size: 0.9em;
}

.reply-to-user {
    color: #409EFF;
    font-size: 0.9em;
}

.reply-text {
    color: #333;
}

.reply-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
}

.reply-time {
    font-size: 0.8rem;
    color: #909399;
}

.reply-actions {
    display: flex;
    gap: 12px;
}

.nested-reply-form {
    margin-top: 12px;
    padding: 12px;
    background: #fff;
    border-radius: 4px;
}

.nested-reply-form .reply-actions {
    margin-top: 8px;
    justify-content: flex-end;
}

/* ÂìçÂ∫îÂºèË∞ÉÊï¥ */
@media (max-width: 768px) {
    .replies-list {
        margin-left: 24px;
        padding: 12px;
    }

    .reply-content {
        flex-wrap: wrap;
    }
}

/* Ê∑ªÂä†ÊÇ¨ÊµÆÊåâÈíÆÊ†∑Âºè */
.floating-actions {
    position: fixed;
    right: 40px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 16px;
    z-index: 100;
}

.action-button {
    position: relative;
    width: 48px;
    height: 48px;
    border-radius: 24px;
    background: white;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.button-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.like-count,
.comment-count {
    font-size: 12px;
    color: #666;
}

.action-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

.like-button {
    color: #666;
}

.like-button.is-liked {
    color: #409EFF;
    background: #ecf5ff;
}

.tooltip {
    position: absolute;
    right: calc(100% + 8px);
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.75);
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.action-button:hover .tooltip {
    opacity: 1;
    visibility: visible;
}

/* Ê∑ªÂä†Âä®ÁîªÊïàÊûú */
@keyframes likeAnimation {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.like-button:active {
    animation: likeAnimation 0.3s ease;
}

/* ÂìçÂ∫îÂºèË∞ÉÊï¥ */
@media (max-width: 768px) {
    .floating-actions {
        position: fixed;
        right: 16px;
        bottom: 24px;
        top: auto;
        transform: none;
        flex-direction: row;
    }

    .tooltip {
        display: none; /* Âú®ÁßªÂä®Á´ØÈöêËóèÊèêÁ§∫ */
    }
}

.comment-tools {
    display: flex;
    gap: 16px;
    padding: 12px 0;
    border-top: 1px solid #f0f0f0;
    margin-top: 8px;
}

.tool-btn {
    display: flex;
    align-items: center;
    gap: 4px;
    color: #666;
    transition: color 0.3s;
}

.tool-btn:hover {
    color: #409EFF;
}

.emoji-grid {
    display: none;
}

.emoji-item {
    display: none;
}

:deep(.emoji-dropdown) {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    width: 360px;
    padding: 8px;
}

:deep(.emoji-dropdown .el-dropdown-menu__item) {
    justify-content: center;
    padding: 8px;
    font-size: 24px;
    line-height: 1;
}

:deep(.emoji-dropdown .el-dropdown-menu__item:hover) {
    background-color: #f5f7fa;
    transform: scale(1.2);
    transition: all 0.2s ease;
}

:deep(.el-dropdown-menu__item) {
    line-height: 32px;
    padding: 0 16px;
    font-size: 14px;
}

:deep(.el-dropdown-menu__item:hover) {
    background-color: #f5f7fa;
    color: #409EFF;
}

/* ‰øÆÊîπË°®ÊÉÖÁΩëÊ†ºÊ†∑Âºè */
:deep(.emoji-grid-menu) {
    width: 320px;
    padding: 8px;
    display: block !important;
}

:deep(.emoji-grid-container) {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 4px;
}

:deep(.emoji-grid-item) {
    height: 40px;
    padding: 0 !important;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    line-height: 1;
    cursor: pointer;
    transition: all 0.2s ease;
}

:deep(.emoji-grid-item:hover) {
    background-color: #f5f7fa;
    transform: scale(1.2);
}

:deep(.emoji-grid-item.el-dropdown-menu__item) {
    min-width: unset;
    line-height: normal;
}

/* ÁßªÈô§‰πãÂâçÁöÑÊ†∑Âºè */
:deep(.emoji-dropdown) {
    display: none;
}
</style>